

# JIT-компилятор (МФТИ 2023)
____

## Цель работы
Исследование процесса JIT-компиляции и кодирования команд ассемблера x86.

## Введение
**JIT-компиляция** (*Just-in-time*) или **динамическая компиляция** - компиляция *байт-кода* в машинный непосредственно во время исполнения программы. Данная технология используется для увелечения скорости выполнения программы в сравнении с сохраняемым байт-кодом, а также для реализации более гибких оптимизаций за счёт возможности их осуществления прямо во время исполнения. **Байт-код** представляет из себя компактное промежуточное представление программы в побитовом виде, которое позволяет осуществлять быстрое взаимодействие между частями системы.


## Реализация
В данной работе будем компилировать байт-код, созданный собственным ассемблером из репозитория https://github.com/Art8mish/Processor. В учебных целях синтаксис сильно урезан, по сравнению с реальным ассемблером x86, и представляет из себя небольшой набор команд, которые и будут транслироваться в исполняемый буффер. Регистров также сильно меньше (`rax`, `rcx`, `rdx`, `rbx`), но для реализации команд будут использованы также `rdi` и `rsi`. Дальше будут представлены сами инструкции и частично разобран принцип кодирования в архитектуре x86-64.

### Команды собственного ассемблера

</b></details>
<details>   
<summary> Список команд </summary><br><b>

- PUSH reg/mem/cnst
- POP reg/mem

- JMP
- CALL

- JB
- JBE
- JA
- JAE
- JE
- JNE

- ADD
- SUB
- MUL
- DIV

- OUT
- IN

</b></details>

Команда PUSH помещает в стек константу, значение регистра или значение ячейки памяти, POP аналогично забирает значение из стека и кладёт в регистр или ячейку памяти (в нашем случае будем использовать только регистр). JMP и CALL представляют из себя переходы, в качестве аргумента принимается метка. Дальше представлены условные переходы, которые берут два значения из стека и в зависимости от условия производят переход. Арифмитические команды ADD, SUB, MUL и DIV аналогично извлекают два значения из стека, производят операцию и заталкивают результат в стек. OUT выводит в консоль последнее значение в стеке, IN принимает значение из консоли и заталкивает в стек. 

#### Дальше представлены их реализации на ассемблере x86:

- PUSH 5
```asm
push 0x00000005
```

Все числа-константы будут задаваться в 32-разрядном виде (4 байта).

- PUSH/POP rax
```asm
push/pop rax
```

- PUSH/POP [2988 + RAX]
```asm
push/pop [rax + 0x00000BAC]
```

- JMP/CALL 0xEDA
```asm
jmp/call 0x00000EDA
```

- JB/JBE/JA/JAE/JE/JNE 0xEDA
```asm
pop rsi
pop rdi
cmp rdi, rsi
jb/jbe/ja/jae/je/jne 0x00000EDA
```
- ADD/SUB/MUL
```asm
pop rsi
pop rdi
add/sub/imul rdi, rsi
push rdi
```
Стоит отметить, что знаковое умножение *mul* в ассемблерном виде можно представить как *imul*.

- DIV
```asm
pop rsi
pop rdi
push rax
push rdx
mov rax, rdi
idiv rsi
mov rdi, rax
pop rdx
pop rax
push rdi
```
Конструкция деления довольно велика, по сравнению остальными команандами, а также сильно медленнее. Об особенностях *div* и *idiv* можно прочитать на сайте https://www.club155.ru/x86cmd/IDIV.

- OUT
```asm
movabs rdi, str
pop rsi
push rax
movabs rax, printf_ptr
call rax
pop rax
```
Для вывода чисел используется функция *printf*, указатель на которую копируется в *rax* с помощью `movabs`. Данная инструкция позволяет загрузить абсолютный адрес функции, который в памяти будет представлен в 64-разрядном виде (8 байт) и вызвать её с помощью *call*.

- IN
```asm
mov rdi, rax
movabs rax, __scanf
call rax
push rax
mov rax, rdi
```

Так как в данной задаче не нужен полный функционал *scanf* и память для выделять довольно проблематично, напишем свою сильно упрощенную версию *__scanf* и будем вызывать её.

</b></details>
<details>   
<summary> __scanf </summary><br><b>

```C++
int __scanf()
{
    int num = 0;
    char buf[32] = {0};

    read (0, buf, 32);
    int i = 0;
    while (buf[i] >= '0')
    {
        num *= 10;
        num += buf[i] - '0';
        i += 1;
    }

    return num;
}
```
</b></details>

## Кодирование инструкций x86-64

В данной работе будут разобраны лишь поверхностные принципы кодирования команд ассемблера архитектуры x86-64, подробнее можно прочитать на сайтах, указанных в разделе источников о кодировании команд x86. Если зяглянуть в таблицу http://sparksandflames.com/files/x86InstructionChart.html, можно заметить, что команды сначала кодировались одним байтом, но с развитием технологий одного байта перестало хватать и сейчас для большинства стандартных инструкции представляются в виде одного, двух или трёх байтов. В нашем случае хватит двух, первый байт таких двухбайтных команд - `0x0F`.

Далее для кодирования инструкций будет очень удобно использовать битовые поля, о них подробней можно почитать на сайте https://russianblogs.com/article/1208846117/. Битовые поля позволяют адресоваться к отдельным битам, что будет очень полезно в данной работе.

Структура из двух байтов для кодирования самой команды:
```C++
struct Opcode
{
    int8_t b1 : 8;
    int8_t b2 : 8;
};
```

Дальше для адресации операндов используется байт `ModRM`, состоящий из трёх полей: *mod*, *reg*, *rm*. 

             ModRM
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 
| mod   |    reg    |    rm     |


С помощью него можно закодировать адресацию *[reg_b + reg_r + offs]*, где *reg_b* представляет из себя базу (поле reg), относительно которой производится смещение, а *reg_r* и *offs* регистр общего назначения и константу смещения. Поле *mod* состоит и двух байтов и в совокупности с остальными полями позволяет кодировать разные комбинации данной адресации. 





В этом также помогает следующий опциональный байт `SIB`


картинка
<img src="/imgs/hsh_tbl.png" style="height: 320px;"/>


### Реализация

```C++

```


## Источники и литература
1. JIT-компиляция и байт-код:
    - https://ru.wikipedia.org/wiki/JIT-компиляция
    - https://ru.wikipedia.org/wiki/Байт-код

2. Кодирование команд x86 (справки и мануалы):
    - http://ref.x86asm.net/index.html
    - https://wasm.in/threads/principy-kodirovanija-instrukcij-intel-x86-64-ili-exal-prefiks-cherez-prefiks.34390/
    - https://osdev.fandom.com/ru/wiki/Кодирование_команд

3. Кодирование команд x86 (таблицы):
    - http://sparksandflames.com/files/x86InstructionChart.html
    - http://ref.x86asm.net/coder64.html#two-byte
    - https://shell-storm.org/x86doc/

4. Префиксы
    - https://habr.com/ru/companies/intel/articles/200598/

5. Руководства по mmap и mprotect:
    - https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=mmap&category=2
    - https://www.opennet.ru/man.shtml?topic=mprotect&category=2&russian=0
    - https://linuxhint.com/using_mmap_function_linux/
    - https://it.wikireading.ru/34325

6. Битовые поля:
    - https://ru.wikipedia.org/wiki/Битовое_поле_(C%2B%2B)
    - https://habr.com/ru/articles/142662/
    - https://russianblogs.com/article/1208846117/

7. Остальные использованные полезные материалы
    - https://www.club155.ru/x86cmd/IDIV

6. Онлайн-компилятор GodBolt
    - https://godbolt.org/

Литература:
- Randal E. Bryant and David R. O'Hallaron "Computer Systems: A Programmer's Perspective"
